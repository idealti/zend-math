{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-math Repository abandoned 2019-12-31 This repository has moved to laminas/laminas-math . Zend\\Math provides general mathematical functions. So far the supported functionalities are: Zend\\Math\\Rand , a random number generator; Zend\\Math\\BigInteger , a library to manage big integers. Migration notes from v2 to v3 We document migration notes from v2 to v3 , providing details of potential BC breaks and/or API differences you may need to be aware of. Miscellany File issues at https://github.com/zendframework/zend-math/issues Documentation is at https://docs.zendframework.com/zend-math/","title":"zend-math"},{"location":"#zend-math","text":"","title":"zend-math"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to laminas/laminas-math . Zend\\Math provides general mathematical functions. So far the supported functionalities are: Zend\\Math\\Rand , a random number generator; Zend\\Math\\BigInteger , a library to manage big integers.","title":"Repository abandoned 2019-12-31"},{"location":"#migration-notes-from-v2-to-v3","text":"We document migration notes from v2 to v3 , providing details of potential BC breaks and/or API differences you may need to be aware of.","title":"Migration notes from v2 to v3"},{"location":"#miscellany","text":"File issues at https://github.com/zendframework/zend-math/issues Documentation is at https://docs.zendframework.com/zend-math/","title":"Miscellany"},{"location":"big-integer/","text":"Big Integers Zend\\Math\\BigInteger\\BigInteger offers a class to manage arbitrary length integers. PHP supports integer numbers with a maximum value of PHP_INT_MAX , a value defined by your processor architecture and available memory. If you need to manage integers bigger than PHP_INT_MAX , you need to use external libraries or PHP extensions such as GMP or BC Math . Zend\\Math\\BigInteger\\BigInteger is able to manage big integers using either the GMP or the BC Math extensions as adapters. Methods available The mathematical functions implemented in Zend\\Math\\BigInteger\\BigInteger are: add($leftOperand, $rightOperand) : add two big integers. sub($leftOperand, $rightOperand) : subtract two big integers. mul($leftOperand, $rightOperand) : multiply two big integers. div($leftOperand, $rightOperand) : divide two big integers (this method returns only the integer part of result). pow($operand, $exp) : raise one big integer using the other big integer as the exponent. sqrt($operand) : get the square root of a big integer. abs($operand) : get the absolute value of a big integer. mod($leftOperand, $modulus) : get the modulus of dividing one big integer by another. powmod($leftOperand, $rightOperand, $modulus) : raise a big integer using another big integer as the exponent, and reduce by the specified modulus. comp($leftOperand, $rightOperand) : compare two big integers. Returns < 0 if $leftOperand is less than $rightOperand ; > 0 if $leftOperand is greater than $rightOperand ; and 0 if they are equal. intToBin($int, $twoc = false) : convert a big integer into its binary number representation; binToInt($bytes, $twoc = false) : convert a binary number into a big integer. baseConvert($operand, $fromBase, $toBase = 10) : convert a big integer between arbitrary bases. Examples The example below illustrates using the BC Math adapter to calculate the sum of two random integers with 100 digits each. use Zend\\Math\\BigInteger\\BigInteger; use Zend\\Math\\Rand; $bigInt = BigInteger::factory('bcmath'); $x = Rand::getString(100, '0123456789'); $y = Rand::getString(100, '0123456789'); $sum = $bigInt->add($x, $y); $len = strlen($sum); printf(\"%{$len}s +\\n%{$len}s =\\n%s\\n%s\\n\", $x, $y, str_repeat('-', $len), $sum); Note that the big integers are managed using strings; even the result of the sum is represented as a string. Next is an example using the BC Math adapter to generate the binary representation of a negative big integer containing 100 digits. use Zend\\Math\\BigInteger\\BigInteger; use Zend\\Math\\Rand; $bigInt = BigInteger::factory('bcmath'); $digits = 100; $x = '-' . Rand::getString($digits, '0123456789'); $byte = $bigInt->intToBin($x); printf( \"The binary representation of a big integer with %d digits:\\n%s\\nis (in Base64 format): %s\\n\", $digits $x, base64_encode($byte) ); printf(\"Length in bytes: %d\\n\", strlen($byte)); $byte = $bigInt->intToBin($x, true); printf( \"The two's complement binary representation of the big integer with %d digits:\\n\" . \"%s\\nis (in Base64 format): %s\\n\", $digits, $x, base64_encode($byte) ); printf(\"Length in bytes: %d\\n\", strlen($byte)); The above generates the binary representation of the big integer number using the default binary format, and the two's complement representation (specified with the true parameter in the intToBin function).","title":"Big Integers"},{"location":"big-integer/#big-integers","text":"Zend\\Math\\BigInteger\\BigInteger offers a class to manage arbitrary length integers. PHP supports integer numbers with a maximum value of PHP_INT_MAX , a value defined by your processor architecture and available memory. If you need to manage integers bigger than PHP_INT_MAX , you need to use external libraries or PHP extensions such as GMP or BC Math . Zend\\Math\\BigInteger\\BigInteger is able to manage big integers using either the GMP or the BC Math extensions as adapters.","title":"Big Integers"},{"location":"big-integer/#methods-available","text":"The mathematical functions implemented in Zend\\Math\\BigInteger\\BigInteger are: add($leftOperand, $rightOperand) : add two big integers. sub($leftOperand, $rightOperand) : subtract two big integers. mul($leftOperand, $rightOperand) : multiply two big integers. div($leftOperand, $rightOperand) : divide two big integers (this method returns only the integer part of result). pow($operand, $exp) : raise one big integer using the other big integer as the exponent. sqrt($operand) : get the square root of a big integer. abs($operand) : get the absolute value of a big integer. mod($leftOperand, $modulus) : get the modulus of dividing one big integer by another. powmod($leftOperand, $rightOperand, $modulus) : raise a big integer using another big integer as the exponent, and reduce by the specified modulus. comp($leftOperand, $rightOperand) : compare two big integers. Returns < 0 if $leftOperand is less than $rightOperand ; > 0 if $leftOperand is greater than $rightOperand ; and 0 if they are equal. intToBin($int, $twoc = false) : convert a big integer into its binary number representation; binToInt($bytes, $twoc = false) : convert a binary number into a big integer. baseConvert($operand, $fromBase, $toBase = 10) : convert a big integer between arbitrary bases.","title":"Methods available"},{"location":"big-integer/#examples","text":"The example below illustrates using the BC Math adapter to calculate the sum of two random integers with 100 digits each. use Zend\\Math\\BigInteger\\BigInteger; use Zend\\Math\\Rand; $bigInt = BigInteger::factory('bcmath'); $x = Rand::getString(100, '0123456789'); $y = Rand::getString(100, '0123456789'); $sum = $bigInt->add($x, $y); $len = strlen($sum); printf(\"%{$len}s +\\n%{$len}s =\\n%s\\n%s\\n\", $x, $y, str_repeat('-', $len), $sum); Note that the big integers are managed using strings; even the result of the sum is represented as a string. Next is an example using the BC Math adapter to generate the binary representation of a negative big integer containing 100 digits. use Zend\\Math\\BigInteger\\BigInteger; use Zend\\Math\\Rand; $bigInt = BigInteger::factory('bcmath'); $digits = 100; $x = '-' . Rand::getString($digits, '0123456789'); $byte = $bigInt->intToBin($x); printf( \"The binary representation of a big integer with %d digits:\\n%s\\nis (in Base64 format): %s\\n\", $digits $x, base64_encode($byte) ); printf(\"Length in bytes: %d\\n\", strlen($byte)); $byte = $bigInt->intToBin($x, true); printf( \"The two's complement binary representation of the big integer with %d digits:\\n\" . \"%s\\nis (in Base64 format): %s\\n\", $digits, $x, base64_encode($byte) ); printf(\"Length in bytes: %d\\n\", strlen($byte)); The above generates the binary representation of the big integer number using the default binary format, and the two's complement representation (specified with the true parameter in the intToBin function).","title":"Examples"},{"location":"intro/","text":"Introduction zend-math provides general mathematical functions. So far the supported functionalities are: Zend\\Math\\Rand , a random number generator; Zend\\Math\\BigInteger , a library to manage big integers. We expect to add more functionalities in the future.","title":"Intro"},{"location":"intro/#introduction","text":"zend-math provides general mathematical functions. So far the supported functionalities are: Zend\\Math\\Rand , a random number generator; Zend\\Math\\BigInteger , a library to manage big integers. We expect to add more functionalities in the future.","title":"Introduction"},{"location":"migration/","text":"Migration Guide The following details the changes from the version 2 series to version 3, and how to prepare for migration. New requirements for random number generation For version 3, we changed the random number generator strategy of Zend\\Math\\Rand using the random_int() ad random_bytes() functions of PHP 7. For users still on PHP 5.5+, we now require the random_compact library, which provides a polyfill for these new PHP 7 functions. ext/mbstring required Starting with version 3, we now require the mbstring extension. We added this requirement to ensure that all string manipulations inside zend-math are binary-safe. Internally, we replace all strlen() and substr() functions with the equivalent mb_strlen() and mb_substr() functions, and require 8bit encoding. We removed the $strong optional parameter In Zend\\Math\\Rand , we removed the usage of the $strong optional parameter for the random number generator. By default, all random numbers produced in version 3 releases will use a secure pseudo-random number generator ( CSPRNG ). The following lists the functions from which the parameter was removed: Rand::getBytes($length) Rand::getBoolean() Rand::getInteger($min, $max) Rand::getFloat() Rand::getString($length, $charlist = null) In each case, the $strong parameter was both optional, and the last argument in the list. As PHP allows passing more arguments than the signature accepts, this will not pose a backwards compatibility break; it only means that the argument no longer has any meaning. We recommend removing the parameter from any calls you make to the above functions after migrating. We changed the error management in Rand Several methods now throw exceptions for error situations: Zend\\Math\\Rand::getBytes($length) will no longer return a boolean false when $length <= 0 . Instead, it will now throw a Zend\\Math\\Exception\\DomainException . Zend\\Math\\Rand::getBytes($length) will now throw a Zend\\Math\\Exception\\InvalidArgumentException if the $length parameter is not an integer. Zend\\Math\\Rand::getInteger($min, $max) will now throw a Zend\\Math\\Exception\\InvalidArgumentException if either parameter is not an integer. Additionally, in cases where you are not using PHP 7 and your PHP environment does not provide a secure random source, we now throw a Zend\\Math\\Exception\\RuntimeException with the following message: This PHP environment doesn't support secure random number generation. Please consider upgrading to PHP 7. This message should appear if your are using PHP versions less than 7 on Windows machines without one of the following extensions or libraries installed: Mcrypt libsodium CAPICOM OpenSSL","title":"Migration"},{"location":"migration/#migration-guide","text":"The following details the changes from the version 2 series to version 3, and how to prepare for migration.","title":"Migration Guide"},{"location":"migration/#new-requirements-for-random-number-generation","text":"For version 3, we changed the random number generator strategy of Zend\\Math\\Rand using the random_int() ad random_bytes() functions of PHP 7. For users still on PHP 5.5+, we now require the random_compact library, which provides a polyfill for these new PHP 7 functions.","title":"New requirements for random number generation"},{"location":"migration/#extmbstring-required","text":"Starting with version 3, we now require the mbstring extension. We added this requirement to ensure that all string manipulations inside zend-math are binary-safe. Internally, we replace all strlen() and substr() functions with the equivalent mb_strlen() and mb_substr() functions, and require 8bit encoding.","title":"ext/mbstring required"},{"location":"migration/#we-removed-the-strong-optional-parameter","text":"In Zend\\Math\\Rand , we removed the usage of the $strong optional parameter for the random number generator. By default, all random numbers produced in version 3 releases will use a secure pseudo-random number generator ( CSPRNG ). The following lists the functions from which the parameter was removed: Rand::getBytes($length) Rand::getBoolean() Rand::getInteger($min, $max) Rand::getFloat() Rand::getString($length, $charlist = null) In each case, the $strong parameter was both optional, and the last argument in the list. As PHP allows passing more arguments than the signature accepts, this will not pose a backwards compatibility break; it only means that the argument no longer has any meaning. We recommend removing the parameter from any calls you make to the above functions after migrating.","title":"We removed the $strong optional parameter"},{"location":"migration/#we-changed-the-error-management-in-rand","text":"Several methods now throw exceptions for error situations: Zend\\Math\\Rand::getBytes($length) will no longer return a boolean false when $length <= 0 . Instead, it will now throw a Zend\\Math\\Exception\\DomainException . Zend\\Math\\Rand::getBytes($length) will now throw a Zend\\Math\\Exception\\InvalidArgumentException if the $length parameter is not an integer. Zend\\Math\\Rand::getInteger($min, $max) will now throw a Zend\\Math\\Exception\\InvalidArgumentException if either parameter is not an integer. Additionally, in cases where you are not using PHP 7 and your PHP environment does not provide a secure random source, we now throw a Zend\\Math\\Exception\\RuntimeException with the following message: This PHP environment doesn't support secure random number generation. Please consider upgrading to PHP 7. This message should appear if your are using PHP versions less than 7 on Windows machines without one of the following extensions or libraries installed: Mcrypt libsodium CAPICOM OpenSSL","title":"We changed the error management in Rand"},{"location":"rand/","text":"Random Number Generation Zend\\Math\\Rand implements a random number generator that is able to generate random numbers for general purpose usage and for cryptographic scopes. To generate good random numbers, this component uses different approaches. If PHP 7 is running, we use the cryptographically secure pseudo-random functions random_bytes() and random_int() . For PHP 5 versions, we use paragonie/random_compat , which delegates to the Mcrypt extension or a /dev/urandom or similar source. If you don't have a secure random source in your environment, the functionality will raise an exception, providing hints regarding extensions it can use. Methods available The Zend\\Math\\Rand class offers the following methods to generate random values: getBytes($length) to generate a random set of $length bytes; getBoolean() to generate a random boolean value (true or false); getInteger($min, $max) to generate a random integer between $min and $max ; getFloat() to generate a random float number between 0 and 1; getString($length, $charlist = null) to generate a random string of $length characters using the alphabet $charlist ; if not provided, the default alphabet is the Base64 character set. Examples The example below demonstrates generating random data using Zend\\Math\\Rand : use Zend\\Math\\Rand; $bytes = Rand::getBytes(32); printf(\"Random bytes (in Base64): %s\\n\", base64_encode($bytes)); $boolean = Rand::getBoolean(); printf(\"Random boolean: %s\\n\", $boolean ? 'true' : 'false'); $integer = Rand::getInteger(0, 1000); printf(\"Random integer in [0-1000]: %d\\n\", $integer); $float = Rand::getFloat(); printf(\"Random float in [0-1): %f\\n\", $float); $string = Rand::getString(32, 'abcdefghijklmnopqrstuvwxyz'); printf(\"Random string in latin alphabet: %s\\n\", $string);","title":"Random Number Generation"},{"location":"rand/#random-number-generation","text":"Zend\\Math\\Rand implements a random number generator that is able to generate random numbers for general purpose usage and for cryptographic scopes. To generate good random numbers, this component uses different approaches. If PHP 7 is running, we use the cryptographically secure pseudo-random functions random_bytes() and random_int() . For PHP 5 versions, we use paragonie/random_compat , which delegates to the Mcrypt extension or a /dev/urandom or similar source. If you don't have a secure random source in your environment, the functionality will raise an exception, providing hints regarding extensions it can use.","title":"Random Number Generation"},{"location":"rand/#methods-available","text":"The Zend\\Math\\Rand class offers the following methods to generate random values: getBytes($length) to generate a random set of $length bytes; getBoolean() to generate a random boolean value (true or false); getInteger($min, $max) to generate a random integer between $min and $max ; getFloat() to generate a random float number between 0 and 1; getString($length, $charlist = null) to generate a random string of $length characters using the alphabet $charlist ; if not provided, the default alphabet is the Base64 character set.","title":"Methods available"},{"location":"rand/#examples","text":"The example below demonstrates generating random data using Zend\\Math\\Rand : use Zend\\Math\\Rand; $bytes = Rand::getBytes(32); printf(\"Random bytes (in Base64): %s\\n\", base64_encode($bytes)); $boolean = Rand::getBoolean(); printf(\"Random boolean: %s\\n\", $boolean ? 'true' : 'false'); $integer = Rand::getInteger(0, 1000); printf(\"Random integer in [0-1000]: %d\\n\", $integer); $float = Rand::getFloat(); printf(\"Random float in [0-1): %f\\n\", $float); $string = Rand::getString(32, 'abcdefghijklmnopqrstuvwxyz'); printf(\"Random string in latin alphabet: %s\\n\", $string);","title":"Examples"}]}